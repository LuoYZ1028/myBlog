{
    "version": "https://jsonfeed.org/version/1",
    "title": "我的博客",
    "description": "",
    "home_page_url": "http://LuoYZ1028.github.io/myBlog",
    "items": [
        {
            "id": "http://luoyz1028.github.io/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/",
            "url": "http://luoyz1028.github.io/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/",
            "title": "LoongArch32位汇编器使用文档",
            "date_published": "2022-10-11T01:23:56.000Z",
            "content_html": "<h1 id=\"基础内容\"><a href=\"#基础内容\" class=\"headerlink\" title=\"基础内容\"></a>基础内容</h1><h2 id=\"代码输入-提示信息\"><a href=\"#代码输入-提示信息\" class=\"headerlink\" title=\"代码输入+提示信息\"></a>代码输入+提示信息</h2><p>在Edit窗口即可输入汇编代码，注意代码高亮提示，如果指令名输完后没有高亮，多半就是指令有误了；</p>\n<img src=\"/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/%E4%BB%A3%E7%A0%81%E5%8C%BA01.png\" class=\"\">\n\n<p>出现错误时，会自动跳转到错误行且行高亮色变为暗红色，改正后再次点击Build按钮或按F5，行高亮色变为暗绿色。</p>\n<img src=\"/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/%E4%BB%A3%E7%A0%81%E5%8C%BA02.png\" class=\"\">\n\n<h2 id=\"结果预览\"><a href=\"#结果预览\" class=\"headerlink\" title=\"结果预览\"></a>结果预览</h2><p>当汇编无语法错误时，可以切换到Result窗口，查看当前指令对应的汇编结果和数据变量的存储情况</p>\n<img src=\"/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/%E7%BB%93%E6%9E%9C%E9%A2%84%E8%A7%88.png\" class=\"\">\n\n<h2 id=\"功能按钮\"><a href=\"#功能按钮\" class=\"headerlink\" title=\"功能按钮\"></a>功能按钮</h2><p>鼠标移动到工具按钮上可显示信息（有对应快捷键时也会进行显示），同理，顶部功能选卡也是如此</p>\n<h1 id=\"Debug教程\"><a href=\"#Debug教程\" class=\"headerlink\" title=\"Debug教程\"></a>Debug教程</h1><h3 id=\"单步执行\"><a href=\"#单步执行\" class=\"headerlink\" title=\"单步执行\"></a>单步执行</h3><p>快捷键为F11</p>\n<img src=\"/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_step.png\" class=\"\">\n\n<h3 id=\"手动重置\"><a href=\"#手动重置\" class=\"headerlink\" title=\"手动重置\"></a>手动重置</h3><p>建议遇到问题时，手动点击重置按钮，或快键键F10</p>\n<h3 id=\"设置断点\"><a href=\"#设置断点\" class=\"headerlink\" title=\"设置断点\"></a>设置断点</h3><p>注意断点需要勾选后面的enable框才会真的生效！</p>\n<img src=\"/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_bp.png\" class=\"\">\n\n<h3 id=\"手动修改内存内容\"><a href=\"#手动修改内存内容\" class=\"headerlink\" title=\"手动修改内存内容\"></a>手动修改内存内容</h3><p>可以通过View按钮跳转到对应地址的内存地址查看其中内容，然后通过Set按钮将内容框中的数据写入该内存地址中</p>\n<img src=\"/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_mem1.png\" class=\"\">\n\n<img src=\"/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_mem2.png\" class=\"\">\n\n<h3 id=\"手动跳转\"><a href=\"#手动跳转\" class=\"headerlink\" title=\"手动跳转\"></a>手动跳转</h3><p>通过写入合法PC值，点击set PC按钮，就能够强制跳转到该地址（或者说，当set PC按下后，再次Step，就能执行该PC值对应的指令了）</p>\n<img src=\"/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_set.png\" class=\"\">\n\n<h1 id=\"汇编语法示例\"><a href=\"#汇编语法示例\" class=\"headerlink\" title=\"汇编语法示例\"></a>汇编语法示例</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ASM\">/*<br>\tsome <br>\tannotation <br>\there<br>*/<br>TEST0 macro X<br>addi.w $a0, X, 0x10<br>xor X, X, X<br>endm<br><br>TEST1 macro Y <br>slli.w Y, $a2, 0x3<br>pcaddu12i Y, 13<br>and Y, Y, Y<br>endm<br><br>.data<br><br>string: .asciz &quot;Hello World!\\r\\n&quot;<br>array:  .word 48, 49, 50, 51, 52<br>buffer: .space 3<br>NUM0\tEQU\t0x20<br><br>.text<br><br>.origin 0x00001000<br><br>main:<br>\tli.w $t2, 0x30 /*<br>\t\tmore<br>\t\tannotation<br>\t\there<br>\t*/ li.w $t2, 0x30<br>    li.w $t2, 0x30\t\t# li.w test<br>\tla $t3, array\t\t# la test<br>\taddi.w $t1, $t1, NUM0\t\t# const define test<br>\tTEST0 $s1\t# macro test<br>\tTEST1 $s2\t# macro test<br>    lu12i.w $a7, 0x80000    \t # a relatively large number<br>    addi.w $a7, $a7, 1<br>    addi.w $a0, $a0, 1024<br>    mulh.w $a3, $a7, $a0<br>    beq $a7, $a7, main\t\t        # dead loop<br>    st.w $a7, $t0, 0<br>    st.b $a0, $t0, 0xc<br>    xor $a7, $a7, $a7<br>    xor $a0, $a0, $a0<br>    addi.w $a7, $a7, 93             # exit syscall number<br>    addi.w $a0, $a0, 0<br>    syscall 0x0                     # syscall<br></code></pre></td></tr></table></figure>",
            "tags": []
        },
        {
            "id": "http://luoyz1028.github.io/myBlog/2022/10/08/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/",
            "url": "http://luoyz1028.github.io/myBlog/2022/10/08/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/",
            "title": "LoongArch32位汇编器开发（一）",
            "date_published": "2022-10-08T12:42:41.000Z",
            "content_html": "<h1 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h1><h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>该软件是2022年秋季课程《软件设计与实践B》中，我所在小组决定的课题“基于LoongArch32位CPU设计”，其下的一个子任务。</p>\n<ul>\n<li>基础目标是拥有一个可视化界面的“翻译软件”，能够按顺序翻译汇编语言，支持所有32位基础整数指令集即可，同时要分别支持指令序列和数据变量的分别翻译，最好要能够使用文件读入和写出</li>\n<li>若能实现更多功能，会视情况得到加分</li>\n</ul>\n<h2 id=\"计划技术路线\"><a href=\"#计划技术路线\" class=\"headerlink\" title=\"计划技术路线\"></a>计划技术路线</h2><p>采用Qt作为前端开发平台，Qt基于C++，用偏向系统的语言进行软件开发不至于到时候答辩被老师低看一眼……<br>Qt能够提供一个设计师面板，在这个界面中，可以通过拖拽可视化的窗口控件，来直接生成界面，也正是这一功能，让我的开发过程中摆脱了大量篇幅（1000+行代码）的空间、布局定义和初始化，集中精力专注于后端逻辑。</p>\n<p>C++和C最大的不同，就是前者面向对象，后者面向过程，且前者能提供大量的字符串处理函数，包括QString数据类型，这都能大幅降低开发难度，<br>因为Qt的可视化控件，比如一个QTextBrowser想要显示一些内容，传入的参数类型就是QString类型，所以我设想了一下，觉得如果整体采用QString数据类型存储指令序列，应该能更有效地达成目的。</p>\n<h2 id=\"工期安排\"><a href=\"#工期安排\" class=\"headerlink\" title=\"工期安排\"></a>工期安排</h2><table>\n<thead>\n<tr>\n<th>周数</th>\n<th>工作安排</th>\n<th>是否完成</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>完成基本翻译功能和最基本的代码输入窗口+结果输出窗口（用于检查翻译是否正确）</td>\n<td>yes</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>完成代码段和数据段分治处理，能完成文件读取和写入，将结果输出窗口废弃，改为处理信息输出窗口</td>\n<td>yes</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>进行界面美化，将代码翻译结果显示在新的窗口中，增加代码检错机制（不能要求用户代码写得尽善尽美），同时增加错误提示机制</td>\n<td>yes</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>增加Debug功能，同时增加语法高亮（能高亮关键词，对用户写代码时起到一定的提示作用），将工具栏填入功能按钮，添加一系列Icon美化图标</td>\n<td>yes</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>完善错误检测机制（大部分能遇见的错误类型都能予以提醒，且发现错误时高亮颜色改变，自动跳转到错误行进行高亮），增加多行注释的支持，增加两个伪指令li.w和la，同时支持EQU宏定义</td>\n<td>yes</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>增加快捷键，增加弹出式提示窗口，将代码输入窗口改为修改敏感，即一旦修改就认为当前内容尚未汇编，若此时用户跳转到结果视察或debug窗口，将会强制返回代码编辑窗口并弹出窗口进行提示；增加代码鲁棒性，将绝大部分类中关键变量设为私有成员，添加对应接口函数</td>\n<td>yes</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>支持宏展开macro的定义和使用，添加相应语法高亮，对代码编辑区增加行号支持，更方便用户使用，添加版权信息，添加用户文档</td>\n<td>yes</td>\n<td></td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "LoongArch",
                "软件开发",
                "汇编器"
            ]
        },
        {
            "id": "http://luoyz1028.github.io/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "url": "http://luoyz1028.github.io/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%EF%BC%88%E4%BA%8C%EF%BC%89/",
            "title": "RISC-V流水线CPU（二）",
            "date_published": "2022-10-06T11:54:43.000Z",
            "content_html": "<h1 id=\"前文传送门\"><a href=\"#前文传送门\" class=\"headerlink\" title=\"前文传送门\"></a>前文传送门</h1><a href=\"/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/\" title=\"RISC-V流水线CPU（一）\">第一章</a>\n\n<h2 id=\"数据冒险（续）\"><a href=\"#数据冒险（续）\" class=\"headerlink\" title=\"数据冒险（续）\"></a>数据冒险（续）</h2><h3 id=\"load-use型\"><a href=\"#load-use型\" class=\"headerlink\" title=\"load-use型\"></a>load-use型</h3><p>前面三种数据冒险都能通过前递（forwarding）数据来得以解决，免除了暂停流水线的苦恼，靶特，凡事总有例外，前递并非万用药，load-use型数据冒险就难以使用前递解决，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ASM\">ld x2, 0(x0)    # 从内存0地址取数放入x2<br>addi x2, x2, 1  # x2增1<br></code></pre></td></tr></table></figure>\n<p>load-use，顾名思义，就是取出即用，前面ld指令紧跟着要使用ld的目的寄存器的指令；我们分析一下时序关系，ld什么时候能取出数据？MEM阶段完成时，那么addi什么时候需要用这个数据？EXE阶段开始时；</p>\n<p>显然，二者差了整整一个时钟周期！</p>\n<p>除非强行破坏我们目前的严格5段流水线，在前面阶段就允许访存，否则，面对load-use数据冒险，我们只能委曲求全，插入一个空指令，或者说，让流水线暂停1个周期，然后再数据前递</p>\n<h3 id=\"暂停流水线\"><a href=\"#暂停流水线\" class=\"headerlink\" title=\"暂停流水线\"></a>暂停流水线</h3><p>按理说，面对数据冒险，应该第一反应是想直接暂停流水线的，有冒险，那就等一等、停一停，等到它不再有冒险了，再继续流动；</p>\n<p>这种朴素地解决方案的确存在，但没有多大的实际价值，毕竟已经掌握数据前递的我们不难看出，如果一遇到数据冒险就暂停流水线，那对于指令吞吐量而言将是多大的损失啊！这种“鸵鸟”策略在本设计中并不可取。</p>\n<p>但是对于上述的load-use型冒险，在不破坏严格5段流水分工的前提下，这种暂停手段就成了我们<strong>折中</strong>的策略</p>\n<p>显然我们需要一个<strong>异步</strong>检测信号，这个信号要能够使得流水寄存器暂停一个周期——具体而言就是让发生load-use的那一周期中，让<strong>IF</strong>和<strong>ID</strong>流水寄存器当前周期的输出和下一个周期的输出保持一致，让<strong>EXE</strong>流水寄存器下周期输出清空，这样后续指令就相当于被<strong>卡</strong>了一个周期，谓之暂停。</p>\n<h2 id=\"控制冒险\"><a href=\"#控制冒险\" class=\"headerlink\" title=\"控制冒险\"></a>控制冒险</h2><p>也叫做“分支冒险”，我们认为：程序的<strong>控制流</strong>就像一条工业生产线，不断地有新指令流入，旧指令流出，这是指令执行序列的常态，但是生产向也并非总是按照固定的顺序流动的，最典型的<em>if-else</em>语句，就可能产生分支，令控制流转到另一个特定的位置；</p>\n<p><em>if-else</em>语句无疑是编程语言的一大家，但<em>if-else</em>对流水线并不友好，理由是显而易见的：</p>\n<ul>\n<li>跳转指令，除了无条件跳转，都只有在执行到<strong>EXE</strong>阶段时，才能确定是否真的要跳转</li>\n<li>如果真的需要跳转，那么我们目前的流水线就可能已流入两条错误的指令（分别处于IF和ID阶段），还需要考虑如何handle这两条错误指令引发的<strong>蝴蝶效应</strong></li>\n<li>此外，如何更新PC值也是我们需要考虑的</li>\n</ul>\n<h3 id=\"暂停流水线-插入气泡\"><a href=\"#暂停流水线-插入气泡\" class=\"headerlink\" title=\"暂停流水线+插入气泡\"></a>暂停流水线+插入气泡</h3><p>为了能正确地清理掉流入的两条错误指令，我们可以参考暂停流水线的做法，同时向流水寄存器中插入气泡</p>\n<blockquote>\n<p>注意：<em>暂停流水线</em>和<em>插入气泡</em>是两个概念，前者是让流水寄存器两个周期内输出相同的数据，后者则是让流水寄存器下个周期的输出为“全0”或空</p>\n</blockquote>\n<p>因为我们执行到条件分支指令的EXE阶段才能直到是否需要跳转，所以我们要向<strong>ID，IF</strong>流水寄存器插入气泡，以起到清空错误指令的效果，同时拉高分支信号，告诉PC和NPC模块我们下一步应该如何更新PC值</p>\n<h3 id=\"分支预测\"><a href=\"#分支预测\" class=\"headerlink\" title=\"分支预测\"></a>分支预测</h3><p>可见，即便难如load-use冒险都只需要损失一个时钟周期，而分支指令可能一次性带来两个时钟周期的损失！为优化性能，我们提出了分支预测这一概念。</p>\n<p>为简单起见，我们不考虑通过设置分支预测表来对每一种分支指令都进行预测，而是笼统地设计一个全局分支预测状态机，状态机的状态决定了我们猜测它是跳还是不跳。</p>\n<p>根据状态机的设计原理，大致可分出两类：</p>\n<ol>\n<li>静态预测，典型的有：AJ（永远跳转）,AN（永远不跳转）,BTFNT（往前跳，往后不跳）</li>\n<li>动态预测，最实用的是2bit的状态码</li>\n</ol>\n<p>由于静态预测准确率不高且实现简单，我们不做过多讨论，主要看动态预测的2bit状态机原理图：</p>\n<img src=\"/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8E%9F%E7%90%86.png\" class=\"\" title=\"分支预测原理\"><sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"看不懂也没关系，应该不影响理解原理……吧\">[1]</span></a></sup>\n\n<p>状态码定义为：初值为0，当其值大于 1 时将预测跳转，否侧预测不跳转；<br>我们可以通过枚举法列出动态分支预测的四种情况来进行分析，即：</p>\n<ul>\n<li>预测<em>跳转</em>，实际也<em>跳转</em>（情况 1，预测成功）</li>\n<li>预测<em>不跳转</em>，实际也不<em>跳转</em>（情况 2，预测成功）</li>\n<li>预测<em>跳转</em>，但实际<em>不跳转</em>（情况 3，预测失败）</li>\n<li>预测<em>不跳转</em>，但实际<em>跳转</em>（情况 4，预测失败）</li>\n</ul>\n<ol>\n<li>前两种情况为<strong>预测成功</strong>，则需要正向修正状态码<ul>\n<li>情况1：状态码+1，为什么？因为大于1表示预测跳转，而现在预测跳转对了，自然要鼓励下一次偏向预测跳转</li>\n<li>情况2：状态码-1，为什么？因为小于等于1表示预测不跳转，现在预测不跳转对了，自然要鼓励下一次偏向预测不跳转</li>\n</ul>\n</li>\n<li>后两种情况则为<strong>预测失败</strong>，需要反向修正状态码<ul>\n<li>情况3：状态码-1，为什么？因为小于等于1表示预测不跳转，现在预测跳转错了，应该鼓励下一次偏向预测不跳转</li>\n<li>情况4：状态码+1，为什么？因为大于1表示预测跳转，而现在预测不跳转错了，应该鼓励下一次偏向预测跳转</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>解决了数据冒险和控制冒险后，加上本来采用哈佛结构就能避免冯·诺依曼结构的结构冒险，CPU三大冒险都已解决，流水线CPU就宣告完成了</p>\n<hr>\n<section class=\"footnotes\"><div class=\"footnote-list\"><ol><li><span id=\"fn:1\" class=\"footnote-text\"><span>看不懂也没关系，应该不影响理解原理……吧\n<a href=\"#fnref:1\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li></ol></div></section>",
            "tags": [
                "risc-v",
                "流水线CPU"
            ]
        },
        {
            "id": "http://luoyz1028.github.io/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/",
            "url": "http://luoyz1028.github.io/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/",
            "title": "RISC-V流水线CPU（一）",
            "date_published": "2022-10-06T02:56:19.000Z",
            "content_html": "<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p><a href=\"https://blog.csdn.net/paticita/article/details/119570971\">CSDN相应博客页</a></p>\n<p>里面详细说明了这个项目的来龙去脉，同时对项目的关键点进行了简单的描述，建议结合项目代码进行阅读</p>\n<h1 id=\"内容摘要\"><a href=\"#内容摘要\" class=\"headerlink\" title=\"内容摘要\"></a>内容摘要</h1><blockquote>\n<p>将单周期中已有的分段处理思想进一步实现，通过<strong>流水线寄存器</strong>能够让指令延后一个周期进行传输来划分阶段</p>\n</blockquote>\n<p>完成基本流水线划分后得到的是理想流水线模型，之所以谓之“理想”，是因为这个模型对于存在冲突的指令序列不能正确运行。</p>\n<h1 id=\"流水线整体框架\"><a href=\"#流水线整体框架\" class=\"headerlink\" title=\"流水线整体框架\"></a>流水线整体框架</h1><img src=\"/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%BB%93%E6%9E%84.png\" class=\"\" title=\"流水线结构\"><sup id=\"fnref:1\" class=\"footnote-ref\"><a href=\"#fn:1\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"有一处纰漏：“IF/EXE”应改为“ID/EXE”\">[1]</span></a></sup>\n<blockquote>\n<p>见脚注1</p>\n</blockquote>\n<h1 id=\"解决流水线存在的冲突\"><a href=\"#解决流水线存在的冲突\" class=\"headerlink\" title=\"解决流水线存在的冲突\"></a>解决流水线存在的冲突</h1><h2 id=\"数据冒险\"><a href=\"#数据冒险\" class=\"headerlink\" title=\"数据冒险\"></a>数据冒险</h2><blockquote>\n<p>数据冒险指的是前后两条指令存在<strong>数据相关</strong></p>\n</blockquote>\n<p>即前一条指令产生的数据，将被后一条指令使用，可能是以下情形之一：</p>\n<img src=\"/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/%E6%95%B0%E6%8D%AE%E5%86%B2%E7%AA%81.png\" class=\"\" title=\"数据冲突\"><sup id=\"fnref:2\" class=\"footnote-ref\"><a href=\"#fn:2\" rel=\"footnote\"><span class=\"hint--top hint--rounded\" aria-label=\"同色表示两条指令之间存在该阶段的数据冲突\">[2]</span></a></sup>\n<blockquote>\n<p>见脚注2</p>\n</blockquote>\n<p>我们来分情况讨论一下：</p>\n<h3 id=\"A类数据冒险\"><a href=\"#A类数据冒险\" class=\"headerlink\" title=\"A类数据冒险\"></a>A类数据冒险</h3><p>前一条指令的<strong>访存</strong>阶段和后一条的<strong>执行</strong>阶段冲突，什么意思呢？例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ASM\">li x2, 1        # 把1赋给x2寄存器<br>add x2, x2, x2  # x2寄存器自己加自己<br></code></pre></td></tr></table></figure>\n<p>此刻，当指令 $li\\ x2, 1$ 执行到<strong>MEM</strong>阶段时，后一条指令 $add\\ x2,\\ x2,\\ x2$ 进入<strong>EXE</strong>阶段，发现需要取寄存器x2的值，但如果真的就简单地访问取数，就出现了不一致现象(<em>流水线和单周期行为不一致</em>)，因为我们需要的是更新后x2&#x3D;1的值，但在流水线中，只有当第一条指令转入WB阶段时才会更新x2为1，此前其一直为0；</p>\n<p>所以，我们需要设计<strong>前递单元</strong>(forwarding unit)和<strong>数据冲突检测单元</strong>(hazard detection unit)</p>\n<ul>\n<li>前递：将<em>尚未写回</em>的数据<em>提前</em>送到前面的单元里，以保证数据的有效性</li>\n<li>数据冲突检测：每个时钟周期都对CPU执行的指令进行检测，若发现出现数据冲突，则拉高相应的信号forward_a，使得<em>流水线寄存器</em>得知<em>是否该接收</em>前递单元的数据</li>\n</ul>\n<p>在A类情形中，我们需要将<strong>MEM</strong>阶段的ALU运算结果<strong>前递</strong>到<em>ID&#x2F;EXE流水线寄存器</em>内，这样下一个周期中，后一条指令的ALU操作数就是更新过的结果，而非直接取出的数值</p>\n<h3 id=\"B类数据冒险\"><a href=\"#B类数据冒险\" class=\"headerlink\" title=\"B类数据冒险\"></a>B类数据冒险</h3><p>涉及连续的3条指令，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ASM\">li x2, 1    #把1赋给x2寄存器<br>xor x3, x3, x3  #清空x3寄存器<br>add x2, x2, x2  #x2寄存器自己加自己<br></code></pre></td></tr></table></figure>\n<p>和A类的不同在于发生冲突的两条指令间<strong>夹着</strong>一条指令，即冲突发生在第1条指令的<strong>WB</strong>阶段和第3条指令的<strong>EXE</strong>阶段</p>\n<p>仿照A类的处理方式，将WB阶段的数据前递给ID&#x2F;EXE流水寄存器即可，同样，处理信号需要在<strong>数据冲突检测单元</strong>(hazard detection unit)中确定值，可以令设一个新的前递信号forward_b</p>\n<blockquote>\n<p>思考：当同时存在A，B类型时应该怎么办？</p>\n</blockquote>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ASM\">li x2, 1        # 把1赋给x2寄存器<br>add x2, x2, x2  # x2寄存器自己加自己<br>addi x3, x2, 0  # 同时存在AB两类冲突<br></code></pre></td></tr></table></figure>\n<p>显然我们需要的是最新的数据（<em>newest first原理</em>），即我们可以得出结论：A类数据冲突优先级比B类更高</p>\n<h3 id=\"C类数据冒险\"><a href=\"#C类数据冒险\" class=\"headerlink\" title=\"C类数据冒险\"></a>C类数据冒险</h3><p>这回是发生冲突的两条指令间夹了两条指令，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ASM\">li x2, 1        # 把1赋给x2寄存器<br>add x1, x1, x1  # x1寄存器自己加自己<br>addi x3, x4, 0<br>addi x2, x2, 1  # C类数据冒险<br></code></pre></td></tr></table></figure>\n<p>你可能会问：明明第1条指令已经到WB阶段了，为什么还会发生冲突呢？</p>\n<p>答案是：为了提升主频，我们的寄存器堆采用的是在同一个时钟周期内，上升沿写入，下降沿读取，然而流水线寄存器的流入值也是在上升沿……</p>\n<p><strong>说人话就是</strong>，在同一个周期里，寄存器堆虽然能读出新值，但旧值已经流入ID&#x2F;EXE流水寄存器里了，因此还是需要前递单元操作一下的</p>\n<h3 id=\"load-use型数据冒险\"><a href=\"#load-use型数据冒险\" class=\"headerlink\" title=\"load-use型数据冒险\"></a>load-use型数据冒险</h3><p>请见后续章节</p>\n<a href=\"/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%EF%BC%88%E4%BA%8C%EF%BC%89/\" title=\"RISC-V流水线CPU（二）\">第二章</a>\n\n<hr>\n<section class=\"footnotes\"><div class=\"footnote-list\"><ol><li><span id=\"fn:1\" class=\"footnote-text\"><span>有一处纰漏：“IF&#x2F;EXE”应改为“ID&#x2F;EXE”\n<a href=\"#fnref:1\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li><li><span id=\"fn:2\" class=\"footnote-text\"><span>同色表示两条指令之间存在该阶段的数据冲突\n<a href=\"#fnref:2\" rev=\"footnote\" class=\"footnote-backref\"> ↩</a></span></span></li></ol></div></section>",
            "tags": [
                "risc-v",
                "流水线CPU"
            ]
        },
        {
            "id": "http://luoyz1028.github.io/myBlog/2022/10/05/RISC-V%E5%8D%95%E5%91%A8%E6%9C%9FCPU/",
            "url": "http://luoyz1028.github.io/myBlog/2022/10/05/RISC-V%E5%8D%95%E5%91%A8%E6%9C%9FCPU/",
            "title": "RISC-V单周期CPU",
            "date_published": "2022-10-05T12:00:21.000Z",
            "content_html": "<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><blockquote>\n<p><a href=\"https://blog.csdn.net/paticita/article/details/119508499\">CSDN相关博客页</a></p>\n</blockquote>\n<p>里面详细说明了这个项目的来龙去脉，同时对项目的关键点进行了简单的描述，建议结合项目代码进行阅读</p>\n<h1 id=\"内容摘要\"><a href=\"#内容摘要\" class=\"headerlink\" title=\"内容摘要\"></a>内容摘要</h1><ul>\n<li>使用Verilog语言，配合Vivado软件进行硬件设计，并最终能生成比特流导入板子进行实际效果模拟</li>\n<li>指令集架构基于risc-v，32位基础整数指令，没有特权指令或是内核态，也不存在中断操作</li>\n<li>该部分是单周期模型，所有指令都限定在一个周期内进行5个阶段：取指$\\to$译码$\\to$执行$\\to$访存$\\to$写回，因此整体时延超大，主频难以提升<ul>\n<li>但这并不意味单周期模型就是废物，相反，单周期模型能够证明我们设计的合理性</li>\n<li>此外单周期模型提供5段流水的思想，能够大幅度减少流水线CPU的设计难度</li>\n<li>忽视单周期模型的设计很可能会导致流水线的Bug多如牛毛，不过单周期确实没有多大的实际应用意义</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "risc-v",
                "单周期CPU"
            ]
        }
    ]
}