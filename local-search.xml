<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LoongArch32位汇编器使用文档</title>
    <link href="/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <url>/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h1><h2 id="代码输入-提示信息"><a href="#代码输入-提示信息" class="headerlink" title="代码输入+提示信息"></a>代码输入+提示信息</h2><p>在Edit窗口即可输入汇编代码，注意代码高亮提示，如果指令名输完后没有高亮，多半就是指令有误了；</p><img src="/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/%E4%BB%A3%E7%A0%81%E5%8C%BA01.png" class=""><p>出现错误时，会自动跳转到错误行且行高亮色变为暗红色，改正后再次点击Build按钮或按F5，行高亮色变为暗绿色。</p><img src="/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/%E4%BB%A3%E7%A0%81%E5%8C%BA02.png" class=""><h2 id="结果预览"><a href="#结果预览" class="headerlink" title="结果预览"></a>结果预览</h2><p>当汇编无语法错误时，可以切换到Result窗口，查看当前指令对应的汇编结果和数据变量的存储情况</p><img src="/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/%E7%BB%93%E6%9E%9C%E9%A2%84%E8%A7%88.png" class=""><h2 id="功能按钮"><a href="#功能按钮" class="headerlink" title="功能按钮"></a>功能按钮</h2><p>鼠标移动到工具按钮上可显示信息（有对应快捷键时也会进行显示），同理，顶部功能选卡也是如此</p><h1 id="Debug教程"><a href="#Debug教程" class="headerlink" title="Debug教程"></a>Debug教程</h1><h3 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><p>快捷键为F11</p><img src="/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_step.png" class=""><h3 id="手动重置"><a href="#手动重置" class="headerlink" title="手动重置"></a>手动重置</h3><p>建议遇到问题时，手动点击重置按钮，或快键键F10</p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>注意断点需要勾选后面的enable框才会真的生效！</p><img src="/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_bp.png" class=""><h3 id="手动修改内存内容"><a href="#手动修改内存内容" class="headerlink" title="手动修改内存内容"></a>手动修改内存内容</h3><p>可以通过View按钮跳转到对应地址的内存地址查看其中内容，然后通过Set按钮将内容框中的数据写入该内存地址中</p><img src="/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_mem1.png" class=""><img src="/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_mem2.png" class=""><h3 id="手动跳转"><a href="#手动跳转" class="headerlink" title="手动跳转"></a>手动跳转</h3><p>通过写入合法PC值，点击set PC按钮，就能够强制跳转到该地址（或者说，当set PC按下后，再次Step，就能执行该PC值对应的指令了）</p><img src="/myBlog/2022/10/11/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/Debug_set.png" class=""><h1 id="汇编语法示例"><a href="#汇编语法示例" class="headerlink" title="汇编语法示例"></a>汇编语法示例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs ASM">/*<br>some <br>annotation <br>here<br>*/<br>TEST0 macro X<br>addi.w $a0, X, 0x10<br>xor X, X, X<br>endm<br><br>TEST1 macro Y <br>slli.w Y, $a2, 0x3<br>pcaddu12i Y, 13<br>and Y, Y, Y<br>endm<br><br>.data<br><br>string: .asciz &quot;Hello World!\r\n&quot;<br>array:  .word 48, 49, 50, 51, 52<br>buffer: .space 3<br>NUM0EQU0x20<br><br>.text<br><br>.origin 0x00001000<br><br>main:<br>li.w $t2, 0x30 /*<br>more<br>annotation<br>here<br>*/ li.w $t2, 0x30<br>    li.w $t2, 0x30# li.w test<br>la $t3, array# la test<br>addi.w $t1, $t1, NUM0# const define test<br>TEST0 $s1# macro test<br>TEST1 $s2# macro test<br>    lu12i.w $a7, 0x80000     # a relatively large number<br>    addi.w $a7, $a7, 1<br>    addi.w $a0, $a0, 1024<br>    mulh.w $a3, $a7, $a0<br>    beq $a7, $a7, main        # dead loop<br>    st.w $a7, $t0, 0<br>    st.b $a0, $t0, 0xc<br>    xor $a7, $a7, $a7<br>    xor $a0, $a0, $a0<br>    addi.w $a7, $a7, 93             # exit syscall number<br>    addi.w $a0, $a0, 0<br>    syscall 0x0                     # syscall<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LoongArch32位汇编器开发（一）</title>
    <link href="/myBlog/2022/10/08/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/myBlog/2022/10/08/LoongArch32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>该软件是2022年秋季课程《软件设计与实践B》中，我所在小组决定的课题“基于LoongArch32位CPU设计”，其下的一个子任务。</p><ul><li>基础目标是拥有一个可视化界面的“翻译软件”，能够按顺序翻译汇编语言，支持所有32位基础整数指令集即可，同时要分别支持指令序列和数据变量的分别翻译，最好要能够使用文件读入和写出</li><li>若能实现更多功能，会视情况得到加分</li></ul><h2 id="计划技术路线"><a href="#计划技术路线" class="headerlink" title="计划技术路线"></a>计划技术路线</h2><p>采用Qt作为前端开发平台，Qt基于C++，用偏向系统的语言进行软件开发不至于到时候答辩被老师低看一眼……<br>Qt能够提供一个设计师面板，在这个界面中，可以通过拖拽可视化的窗口控件，来直接生成界面，也正是这一功能，让我的开发过程中摆脱了大量篇幅（1000+行代码）的空间、布局定义和初始化，集中精力专注于后端逻辑。</p><p>C++和C最大的不同，就是前者面向对象，后者面向过程，且前者能提供大量的字符串处理函数，包括QString数据类型，这都能大幅降低开发难度，<br>因为Qt的可视化控件，比如一个QTextBrowser想要显示一些内容，传入的参数类型就是QString类型，所以我设想了一下，觉得如果整体采用QString数据类型存储指令序列，应该能更有效地达成目的。</p><h2 id="工期安排"><a href="#工期安排" class="headerlink" title="工期安排"></a>工期安排</h2><table><thead><tr><th>周数</th><th>工作安排</th><th>是否完成</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>完成基本翻译功能和最基本的代码输入窗口+结果输出窗口（用于检查翻译是否正确）</td><td>yes</td><td></td></tr><tr><td>2</td><td>完成代码段和数据段分治处理，能完成文件读取和写入，将结果输出窗口废弃，改为处理信息输出窗口</td><td>yes</td><td></td></tr><tr><td>3</td><td>进行界面美化，将代码翻译结果显示在新的窗口中，增加代码检错机制（不能要求用户代码写得尽善尽美），同时增加错误提示机制</td><td>yes</td><td></td></tr><tr><td>4</td><td>增加Debug功能，同时增加语法高亮（能高亮关键词，对用户写代码时起到一定的提示作用），将工具栏填入功能按钮，添加一系列Icon美化图标</td><td>yes</td><td></td></tr><tr><td>5</td><td>完善错误检测机制（大部分能遇见的错误类型都能予以提醒，且发现错误时高亮颜色改变，自动跳转到错误行进行高亮），增加多行注释的支持，增加两个伪指令li.w和la，同时支持EQU宏定义</td><td>yes</td><td></td></tr><tr><td>6</td><td>增加快捷键，增加弹出式提示窗口，将代码输入窗口改为修改敏感，即一旦修改就认为当前内容尚未汇编，若此时用户跳转到结果视察或debug窗口，将会强制返回代码编辑窗口并弹出窗口进行提示；增加代码鲁棒性，将绝大部分类中关键变量设为私有成员，添加对应接口函数</td><td>yes</td><td></td></tr><tr><td>7</td><td>支持宏展开macro的定义和使用，添加相应语法高亮，对代码编辑区增加行号支持，更方便用户使用，添加版权信息，添加用户文档</td><td>yes</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>LoongArch</category>
      
      <category>汇编器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LoongArch</tag>
      
      <tag>软件开发</tag>
      
      <tag>汇编器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V流水线CPU（二）</title>
    <link href="/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前文传送门"><a href="#前文传送门" class="headerlink" title="前文传送门"></a>前文传送门</h1><a href="/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/" title="RISC-V流水线CPU（一）">第一章</a><h2 id="数据冒险（续）"><a href="#数据冒险（续）" class="headerlink" title="数据冒险（续）"></a>数据冒险（续）</h2><h3 id="load-use型"><a href="#load-use型" class="headerlink" title="load-use型"></a>load-use型</h3><p>前面三种数据冒险都能通过前递（forwarding）数据来得以解决，免除了暂停流水线的苦恼，靶特，凡事总有例外，前递并非万用药，load-use型数据冒险就难以使用前递解决，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ASM">ld x2, 0(x0)    # 从内存0地址取数放入x2<br>addi x2, x2, 1  # x2增1<br></code></pre></td></tr></table></figure><p>load-use，顾名思义，就是取出即用，前面ld指令紧跟着要使用ld的目的寄存器的指令；我们分析一下时序关系，ld什么时候能取出数据？MEM阶段完成时，那么addi什么时候需要用这个数据？EXE阶段开始时；</p><p>显然，二者差了整整一个时钟周期！</p><p>除非强行破坏我们目前的严格5段流水线，在前面阶段就允许访存，否则，面对load-use数据冒险，我们只能委曲求全，插入一个空指令，或者说，让流水线暂停1个周期，然后再数据前递</p><h3 id="暂停流水线"><a href="#暂停流水线" class="headerlink" title="暂停流水线"></a>暂停流水线</h3><p>按理说，面对数据冒险，应该第一反应是想直接暂停流水线的，有冒险，那就等一等、停一停，等到它不再有冒险了，再继续流动；</p><p>这种朴素地解决方案的确存在，但没有多大的实际价值，毕竟已经掌握数据前递的我们不难看出，如果一遇到数据冒险就暂停流水线，那对于指令吞吐量而言将是多大的损失啊！这种“鸵鸟”策略在本设计中并不可取。</p><p>但是对于上述的load-use型冒险，在不破坏严格5段流水分工的前提下，这种暂停手段就成了我们<strong>折中</strong>的策略</p><p>显然我们需要一个<strong>异步</strong>检测信号，这个信号要能够使得流水寄存器暂停一个周期——具体而言就是让发生load-use的那一周期中，让<strong>IF</strong>和<strong>ID</strong>流水寄存器当前周期的输出和下一个周期的输出保持一致，让<strong>EXE</strong>流水寄存器下周期输出清空，这样后续指令就相当于被<strong>卡</strong>了一个周期，谓之暂停。</p><h2 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h2><p>也叫做“分支冒险”，我们认为：程序的<strong>控制流</strong>就像一条工业生产线，不断地有新指令流入，旧指令流出，这是指令执行序列的常态，但是生产向也并非总是按照固定的顺序流动的，最典型的<em>if-else</em>语句，就可能产生分支，令控制流转到另一个特定的位置；</p><p><em>if-else</em>语句无疑是编程语言的一大家，但<em>if-else</em>对流水线并不友好，理由是显而易见的：</p><ul><li>跳转指令，除了无条件跳转，都只有在执行到<strong>EXE</strong>阶段时，才能确定是否真的要跳转</li><li>如果真的需要跳转，那么我们目前的流水线就可能已流入两条错误的指令（分别处于IF和ID阶段），还需要考虑如何handle这两条错误指令引发的<strong>蝴蝶效应</strong></li><li>此外，如何更新PC值也是我们需要考虑的</li></ul><h3 id="暂停流水线-插入气泡"><a href="#暂停流水线-插入气泡" class="headerlink" title="暂停流水线+插入气泡"></a>暂停流水线+插入气泡</h3><p>为了能正确地清理掉流入的两条错误指令，我们可以参考暂停流水线的做法，同时向流水寄存器中插入气泡</p><blockquote><p>注意：<em>暂停流水线</em>和<em>插入气泡</em>是两个概念，前者是让流水寄存器两个周期内输出相同的数据，后者则是让流水寄存器下个周期的输出为“全0”或空</p></blockquote><p>因为我们执行到条件分支指令的EXE阶段才能直到是否需要跳转，所以我们要向<strong>ID，IF</strong>流水寄存器插入气泡，以起到清空错误指令的效果，同时拉高分支信号，告诉PC和NPC模块我们下一步应该如何更新PC值</p><h3 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h3><p>可见，即便难如load-use冒险都只需要损失一个时钟周期，而分支指令可能一次性带来两个时钟周期的损失！为优化性能，我们提出了分支预测这一概念。</p><p>为简单起见，我们不考虑通过设置分支预测表来对每一种分支指令都进行预测，而是笼统地设计一个全局分支预测状态机，状态机的状态决定了我们猜测它是跳还是不跳。</p><p>根据状态机的设计原理，大致可分出两类：</p><ol><li>静态预测，典型的有：AJ（永远跳转）,AN（永远不跳转）,BTFNT（往前跳，往后不跳）</li><li>动态预测，最实用的是2bit的状态码</li></ol><p>由于静态预测准确率不高且实现简单，我们不做过多讨论，主要看动态预测的2bit状态机原理图：</p><img src="/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%8E%9F%E7%90%86.png" class="" title="分支预测原理"><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="看不懂也没关系，应该不影响理解原理……吧">[1]</span></a></sup><p>状态码定义为：初值为0，当其值大于 1 时将预测跳转，否侧预测不跳转；<br>我们可以通过枚举法列出动态分支预测的四种情况来进行分析，即：</p><ul><li>预测<em>跳转</em>，实际也<em>跳转</em>（情况 1，预测成功）</li><li>预测<em>不跳转</em>，实际也不<em>跳转</em>（情况 2，预测成功）</li><li>预测<em>跳转</em>，但实际<em>不跳转</em>（情况 3，预测失败）</li><li>预测<em>不跳转</em>，但实际<em>跳转</em>（情况 4，预测失败）</li></ul><ol><li>前两种情况为<strong>预测成功</strong>，则需要正向修正状态码<ul><li>情况1：状态码+1，为什么？因为大于1表示预测跳转，而现在预测跳转对了，自然要鼓励下一次偏向预测跳转</li><li>情况2：状态码-1，为什么？因为小于等于1表示预测不跳转，现在预测不跳转对了，自然要鼓励下一次偏向预测不跳转</li></ul></li><li>后两种情况则为<strong>预测失败</strong>，需要反向修正状态码<ul><li>情况3：状态码-1，为什么？因为小于等于1表示预测不跳转，现在预测跳转错了，应该鼓励下一次偏向预测不跳转</li><li>情况4：状态码+1，为什么？因为大于1表示预测跳转，而现在预测不跳转错了，应该鼓励下一次偏向预测跳转</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>解决了数据冒险和控制冒险后，加上本来采用哈佛结构就能避免冯·诺依曼结构的结构冒险，CPU三大冒险都已解决，流水线CPU就宣告完成了</p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>看不懂也没关系，应该不影响理解原理……吧<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>RISC-V</category>
      
      <category>CPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>risc-v</tag>
      
      <tag>流水线CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V流水线CPU（一）</title>
    <link href="/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/"/>
    <url>/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><a href="https://blog.csdn.net/paticita/article/details/119570971">CSDN相应博客页</a></p><p>里面详细说明了这个项目的来龙去脉，同时对项目的关键点进行了简单的描述，建议结合项目代码进行阅读</p><h1 id="内容摘要"><a href="#内容摘要" class="headerlink" title="内容摘要"></a>内容摘要</h1><blockquote><p>将单周期中已有的分段处理思想进一步实现，通过<strong>流水线寄存器</strong>能够让指令延后一个周期进行传输来划分阶段</p></blockquote><p>完成基本流水线划分后得到的是理想流水线模型，之所以谓之“理想”，是因为这个模型对于存在冲突的指令序列不能正确运行。</p><h1 id="流水线整体框架"><a href="#流水线整体框架" class="headerlink" title="流水线整体框架"></a>流水线整体框架</h1><img src="/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%BB%93%E6%9E%84.png" class="" title="流水线结构"><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="有一处纰漏：“IF/EXE”应改为“ID/EXE”">[1]</span></a></sup><blockquote><p>见脚注1</p></blockquote><h1 id="解决流水线存在的冲突"><a href="#解决流水线存在的冲突" class="headerlink" title="解决流水线存在的冲突"></a>解决流水线存在的冲突</h1><h2 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h2><blockquote><p>数据冒险指的是前后两条指令存在<strong>数据相关</strong></p></blockquote><p>即前一条指令产生的数据，将被后一条指令使用，可能是以下情形之一：</p><img src="/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU/%E6%95%B0%E6%8D%AE%E5%86%B2%E7%AA%81.png" class="" title="数据冲突"><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="同色表示两条指令之间存在该阶段的数据冲突">[2]</span></a></sup><blockquote><p>见脚注2</p></blockquote><p>我们来分情况讨论一下：</p><h3 id="A类数据冒险"><a href="#A类数据冒险" class="headerlink" title="A类数据冒险"></a>A类数据冒险</h3><p>前一条指令的<strong>访存</strong>阶段和后一条的<strong>执行</strong>阶段冲突，什么意思呢？例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ASM">li x2, 1        # 把1赋给x2寄存器<br>add x2, x2, x2  # x2寄存器自己加自己<br></code></pre></td></tr></table></figure><p>此刻，当指令 $li\ x2, 1$ 执行到<strong>MEM</strong>阶段时，后一条指令 $add\ x2,\ x2,\ x2$ 进入<strong>EXE</strong>阶段，发现需要取寄存器x2的值，但如果真的就简单地访问取数，就出现了不一致现象(<em>流水线和单周期行为不一致</em>)，因为我们需要的是更新后x2&#x3D;1的值，但在流水线中，只有当第一条指令转入WB阶段时才会更新x2为1，此前其一直为0；</p><p>所以，我们需要设计<strong>前递单元</strong>(forwarding unit)和<strong>数据冲突检测单元</strong>(hazard detection unit)</p><ul><li>前递：将<em>尚未写回</em>的数据<em>提前</em>送到前面的单元里，以保证数据的有效性</li><li>数据冲突检测：每个时钟周期都对CPU执行的指令进行检测，若发现出现数据冲突，则拉高相应的信号forward_a，使得<em>流水线寄存器</em>得知<em>是否该接收</em>前递单元的数据</li></ul><p>在A类情形中，我们需要将<strong>MEM</strong>阶段的ALU运算结果<strong>前递</strong>到<em>ID&#x2F;EXE流水线寄存器</em>内，这样下一个周期中，后一条指令的ALU操作数就是更新过的结果，而非直接取出的数值</p><h3 id="B类数据冒险"><a href="#B类数据冒险" class="headerlink" title="B类数据冒险"></a>B类数据冒险</h3><p>涉及连续的3条指令，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ASM">li x2, 1    #把1赋给x2寄存器<br>xor x3, x3, x3  #清空x3寄存器<br>add x2, x2, x2  #x2寄存器自己加自己<br></code></pre></td></tr></table></figure><p>和A类的不同在于发生冲突的两条指令间<strong>夹着</strong>一条指令，即冲突发生在第1条指令的<strong>WB</strong>阶段和第3条指令的<strong>EXE</strong>阶段</p><p>仿照A类的处理方式，将WB阶段的数据前递给ID&#x2F;EXE流水寄存器即可，同样，处理信号需要在<strong>数据冲突检测单元</strong>(hazard detection unit)中确定值，可以令设一个新的前递信号forward_b</p><blockquote><p>思考：当同时存在A，B类型时应该怎么办？</p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ASM">li x2, 1        # 把1赋给x2寄存器<br>add x2, x2, x2  # x2寄存器自己加自己<br>addi x3, x2, 0  # 同时存在AB两类冲突<br></code></pre></td></tr></table></figure><p>显然我们需要的是最新的数据（<em>newest first原理</em>），即我们可以得出结论：A类数据冲突优先级比B类更高</p><h3 id="C类数据冒险"><a href="#C类数据冒险" class="headerlink" title="C类数据冒险"></a>C类数据冒险</h3><p>这回是发生冲突的两条指令间夹了两条指令，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ASM">li x2, 1        # 把1赋给x2寄存器<br>add x1, x1, x1  # x1寄存器自己加自己<br>addi x3, x4, 0<br>addi x2, x2, 1  # C类数据冒险<br></code></pre></td></tr></table></figure><p>你可能会问：明明第1条指令已经到WB阶段了，为什么还会发生冲突呢？</p><p>答案是：为了提升主频，我们的寄存器堆采用的是在同一个时钟周期内，上升沿写入，下降沿读取，然而流水线寄存器的流入值也是在上升沿……</p><p><strong>说人话就是</strong>，在同一个周期里，寄存器堆虽然能读出新值，但旧值已经流入ID&#x2F;EXE流水寄存器里了，因此还是需要前递单元操作一下的</p><h3 id="load-use型数据冒险"><a href="#load-use型数据冒险" class="headerlink" title="load-use型数据冒险"></a>load-use型数据冒险</h3><p>请见后续章节</p><a href="/myBlog/2022/10/06/RISC-V%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%EF%BC%88%E4%BA%8C%EF%BC%89/" title="RISC-V流水线CPU（二）">第二章</a><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>有一处纰漏：“IF&#x2F;EXE”应改为“ID&#x2F;EXE”<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>同色表示两条指令之间存在该阶段的数据冲突<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>RISC-V</category>
      
      <category>CPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>risc-v</tag>
      
      <tag>流水线CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V单周期CPU</title>
    <link href="/myBlog/2022/10/05/RISC-V%E5%8D%95%E5%91%A8%E6%9C%9FCPU/"/>
    <url>/myBlog/2022/10/05/RISC-V%E5%8D%95%E5%91%A8%E6%9C%9FCPU/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p><a href="https://blog.csdn.net/paticita/article/details/119508499">CSDN相关博客页</a></p></blockquote><p>里面详细说明了这个项目的来龙去脉，同时对项目的关键点进行了简单的描述，建议结合项目代码进行阅读</p><h1 id="内容摘要"><a href="#内容摘要" class="headerlink" title="内容摘要"></a>内容摘要</h1><ul><li>使用Verilog语言，配合Vivado软件进行硬件设计，并最终能生成比特流导入板子进行实际效果模拟</li><li>指令集架构基于risc-v，32位基础整数指令，没有特权指令或是内核态，也不存在中断操作</li><li>该部分是单周期模型，所有指令都限定在一个周期内进行5个阶段：取指$\to$译码$\to$执行$\to$访存$\to$写回，因此整体时延超大，主频难以提升<ul><li>但这并不意味单周期模型就是废物，相反，单周期模型能够证明我们设计的合理性</li><li>此外单周期模型提供5段流水的思想，能够大幅度减少流水线CPU的设计难度</li><li>忽视单周期模型的设计很可能会导致流水线的Bug多如牛毛，不过单周期确实没有多大的实际应用意义</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>RISC-V</category>
      
      <category>CPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>risc-v</tag>
      
      <tag>单周期CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
